# occamsfuncer
a kind of number, an extremely optimizable and scalable universal lambda function meant for number crunching, AI research, and low lag massively multiplayer games that players can redesign into new game types in turingComplete ways by hotswap/forkEditing per bit, per function call pair, etc. Similar to Unlambda, Iota, Jot, Urbit, and Ethereum.

=== EVERYTHING IS A NUMBER ===

A number is either the universal lambda function or a list of 3 numbers: function, parameter, comment. Nothing else exists in the system. Nothing else is needed. A world of a trillion dimensions would be a number.

You may view a number any way you like, but given a number every computer will automatically agree on the shape of its 3-way forest. The shape of its 3-way forest entirely defines a number. Every existing kind of number or information can be represented in this form. Every possible thing in the system, including middle steps while computing, is a number.

=== WHATS OCCAMSFUNCER FOR ===

Occamsfuncer is a kind of number that can do anything imaginable. Like physicists look for a small equation that explains everything around us, occamsfuncer is that for computers. We have many kinds of number which do that, but none so far are efficient enough for practical use and instead collect dust in academic books. Instead of using a rock solid theory of how computers should work, things are normally built by trial-and-error, resulting in many incompatible systems that break often. For example, if theres 2 games you like, you cant just copy/paste a game object from one into the other, even if the rules of the game would allow it, cuz they dont know how to do it without alot of extra work. With a theory-of-everything, all parts can instantly be used in all possible combos. I plan to literally create millions of variations of a new massively multiplayer game per second and have AIs organize them into combos that some groups of the players, who are playing multiple of the game variants live, would think are a better or worse change to the game rules, graphics algorithm, or even changing it into a completely different kind of game or software tool, and all of those things exist simultaneously as long as anyone is interested in pursuing that "multiverse branch" or "multiverse merge". Everything is changeable, negotiable, re-imaginable, combinable, emulatable, encryptable, or even mustache-able if you use the system to build a new part of the system that takes any picture and gives you back a picture of that with a mustache drawn over it such as by convolutional neuralnet or any logic you define, and if you dont like convolutional neuralnets thats fine since they dont exist in the system until derived from simpler logic.

For example, in theory you might build a peer-to-peer agar.io-like game in it, and any player may create a variant of the game from that moment onward where the balls are instead triangles, and each player may choose, or have an AI choose for them, to continue playing as balls or triangles or a split screen of both or both screens overlapping one in green and one in blue or the 2d game becomes 3d with triangles in a 2d layer above the circles, continuing from the moment it forked. This could happen in a single video frame or a few seconds. Other players notice the diverging world and build a new one where some objects are circles and some are triangles and define how they can interact. That may be viewed as a third fork, or maybe most players follow that and are again together in a game of their own design, and they keep  You follow whichever changes you like and ignore those you dont. If enough others go along with what you're doing, how you or your AIs propose people and AIs might interact together (in games, scientific tools, music tools, or whatever you build), then the worlds evolve together like that. Nobody is above anyone else. If you create something and others go along with it, its the same math symmetricly of if they had created it and you're going along with what they're doing. Technically its just a bunch of lambda functions which can fit together however people find useful, with math for how to compute lambdas at gaming-low-lag and securely across a peer-to-peer network or on a single computer or you can even give people executables safely through email.

Occamsfuncer is a certain kind of universal lambda function with plugin hooks to use any number of existing JIT compilers together without breaking compatibility with other systems that use a different set of JIT compilers). We start small and simple and use the numbers to build our way up to a new kind of Internet where everything is instantly compatible with everything else and low lag enough for hardcore gamers and secure enough for operating industrial machines and any pattern of its behaviors are copy/pasteable like today we can only copy/paste text, videos, etc, and there is no discrimination between AIs vs people as we can all use the same tools which build more tools for any purpose we like, and the math of the numbers makes it far easier to create than destroy, and "stand on the shoulders of giants" in tool reuse where tools move as fast as one video frame in a game to the next. When you ask a number about another number, its answer is a number (In other words its a universal lambda function).

=== WHAT KIND OF NUMBER IS OCCAMSFUNCER ===

Occamsfuncer is a kind of number that can do anything imaginable. You start with a 0 dimensional point and ask it about itself (such as by drag-and-drop, TODO), to which it responds another point. You ask these about eachother in various combos to get ever more points, but soon something strange happens... Multiple questions can have the same answer. For every possible answer there are an infinite number of possible questions which give that answer. The same question always gives the same answer, but some questions take too long (potentially infinitely long) to answer so would give up by the max time you told it to take. These numbers start asking eachother questions, building or finding numbers by using eachother in various combos. You get 1 piece of info about each number automatically: Is it the universal lambda function (the "leaf") you started with? Anything else can be figured out by asking that question about multiple combos of asking them about eachother. A number is either leaf or a list of 3 numbers. There are 3 numbers which will give you any of those 3 things. Leaf is [identityFunction leaf leaf], and identityFunction is (((leaf (leaf leaf)) ((leaf leaf) leaf))(((leaf leaf) leaf) (leaf (leaf leaf)))) but we normally see it as "I". There are 16 arbitrarily chosen combos of leaf which do 16 different things, from which all other behaviors are built. Technically these have no name other than the combos of leaf they're made of, but informally we can call them [0 1 left right false true answerIsSameAsQuestion/I ask3ThingsAboutEachother/S isItLeaf pair whatIsItsComment imagineItsCommentIs curry getNthThingAfterCurry selfReference placeToHookInPlugins]. All those are made of leaf. For any x, (imagineIfItsCommentIs (left x (right x)) (whatIsItsComment x)) equals x, but comment has to be leaf if its height without comment is less than 5 since thats where the deepest internal workings of the numbers happens. For example, (left left (right left)) equals left. Using those 16 things, I built a number that tells if 2 numbers equal eachother, built only from parts that can detect if a number is leaf or not. You dont even start with the ability to check if 2 things equal. When I built it, I asked it about 2 of itself and it said true, and I asked it about various other things and it said false. If you want to know what the equals number is made of, you use (left equals) and (right equals) and (whatIsItsComment equals), and keep asking left right andOr comment about what those answer, and so on until all paths eventually lead to leaf. The equals function is built in https://github.com/benrayfield/occamsfuncer/blob/master/immutableexceptgas/occamsfuncerV2Prototype/util/Example.java the part after "equals =". Leaf is in https://github.com/benrayfield/occamsfuncer/blob/master/immutableexceptgas/occamsfuncerV2Prototype/TheUniversalLambdaFunction.java

Those 16 things [0 1 left right false true answerIsSameAsQuestion/I ask3ThingsAboutEachother/S isItLeaf pair whatIsItsComment imagineItsCommentIs curry getNthThingAfterCurry selfReference placeToHookInPlugins]
are built in the prototype at https://github.com/benrayfield/occamsfuncer/blob/master/immutableexceptgas/occamsfuncerV2Spec/Op.java
and https://github.com/benrayfield/occamsfuncer/blob/master/immutableexceptgas/occamsfuncerV2Prototype/util/Boot.java

Test cases are in https://github.com/benrayfield/occamsfuncer/blob/master/immutableexceptgas/occamsfuncerV2Prototype/test/TestBasics.java

=== RELATION TO GODEL INCOMPLETENESS AND HALTING PROBLEM ===

Godel Incompleteness and Halting Problem are both true, such as the halting problem is a statement about parameter/return mappings in the space of all posible functions, and godel incompleteness about a system's ability to prove its own correctness, but this system does not attempt to prove anything and instead only computes <function,parameter,return> triples with a certain selfReferencing design constraint always being true, and it can not detect in advance if a function will halt but it can emulate the next n steps of a function call given as a parameter without calling either of them, and there is space within that (godel incompleteness and halting problem) truth for designing a system to be selfReferencing without losing turingCompleteness, and accept basically a binary form of the "source code" as the definition of equality instead of having to call a function as the only way to measure any info about it, and since a functino can detect this "source code", aka the forest childs recursively, it can affect function behaviors therefore every unique "source code" that is in a halted state (and none can exist that are not halted as those are CallAsKey.java instances instead of fn.java instances) can be detected by another function (all made of various combos of call pairs of the same universal lambda function) to have a different vs the same source code therefore source code is part of function behaviors therefore there is a 1-to-1 mapping between all possible function behaviors and the integers and a function could be created to (however slowly, but in finite time) get the nth possible function behavior when given (some lambda based representation of) the integer n, which can be done by looping over the set of all possible forest shapes, breadth first, only including those that are halted states (sorting is first by height, breaking ties by sorting left, then breaking ties by sorting right, then (if occamsfuncerV2 instead of V1 it has a third "comment" child) breaking ties by sorting comment).

Its a turingComplete subset of lambdas including https://en.wikipedia.org/wiki/SKI_combinator_calculus thats also compatible with https://en.wikipedia.org/wiki/Pattern_calculus

If S = Lx.Ly.Lz.((xz)(yz)), and I = La.a, and LazyEval = Lb.Lc.Ld.bc,

then ((LazyEval ((S I) I)) ((S I) I)), aka (LazyEval (S I I) (S I I)), for every possible parameter, does not halt.

By reducing the set of lambdas to a certain subset, I gain some info about them without losing turingCompleteness. Specificly, only keeping lambdas where ((L x)(R x)) equals x, and L and R are certain combos of call pairs of a certain universal lambda function in https://github.com/benrayfield/occamsfuncer . It gains the ability that a lambda can be built that gets the L and R childs recursively of any parameter lambda. If we did not limit it to that subset of turingComplete lambdas, then there would be no way a lambda could prove any specific info about its parameter (LazyEval (S I I) (S I I)). There are test cases for this in https://github.com/benrayfield/occamsfuncer/blob/master/immutableexceptgas/occamsfuncerV2Prototype/test/TestBasics.java the "testLRQuine" and "testEquals" and "fnThatInfiniteLoopsForEveryPossibleParam" code.

I designed it that way because selfReference is useful, not to change anyone's mind about the possible variations of these academic abstractions.

=== WHY NOBODY CAN CONTROL IT ===

Everything is a number, a kind of number so advanced it can represent any thought you could possibly have and interact with other numbers/thoughts in that context. You can subtract 2 from 7 to get 5, but 2 and 7 still exist, so anyone who has built on the things you've built is unaffected by if you try to change those things and instead it just creates more things and things are only deleted by everyone ignoring them until they are no longer cached not by any action against those things. A number can be affected by "changes" to another number by taking different possible numbers as a parameter, so it is capable of automatic updates such as by digital signatures but in a multiverse of all possible updates so it can be simultaneously updated and not updated and you can even use those multiverse branches together as they are all just numbers, and theres a thing called "mutableWrapperLambda" in theory where if you only digitally sign at most 1 possible answer per each possible question then your public key can be used (with Op.nondet) as a function that just waits until you give an answer to a question you havent answered yet if you ever answer it, and if a key ever gives 2 answers to the same question then forever after that the key takes infinite time for all questions so is effectively blacklisted by not obeying the network protocol that enforces the keys act like lambda functions (mas 1 answer per question deterministicly), though you dont have to call nondet, or allow the calling of nondet, if you're in pure determinism mode in which case every call of Op.nondet takes infinite time.

Nobody is required to use any specific number but may share them and the numbers they contain recursively. Any pair of numbers gives you a third number, if it doesnt give up for taking too long. If you have a number, you can use it with any other number you have to make more numbers. Numbers exist independently of the websites they may be stored at and are guaranteed to compute the exact same bits even if redundantly or partially stored in a million different systems at once that are not normally compatible with eachother. Any system can cache what any other system is doing. Privacy can be had only if you build encryption within the number system and can do any kind of encryption that any computer ever did or could do later even if it hasnt been invented yet, and when it is invented the universal lambda function which all this is built on will not change at all since its already capable of computing everything thats possible to compute.

=== CONTRIBUTING - HOW TO GET ME TO ACCEPT YOUR CODE INTO MY BRANCH HERE ===

The universal lambda function is already defined, but might still have a few bugs in unexpected combos. The only thing left to do is bug fixes, optimizing, and later porting it to other languages such as javascript, android, c++, etc, which will all be compatible with eachother in realtime across the Internet to single bit precision. Its already a general computer so anything so specific features are to be made from calling the universal lambda function on itself in various combos, including arrays for efficiency (which are made of Op.cbt0 and Op.cbt1 as abstract math but are actually stored as arrays in memory). Theres lots of possible ways to optimize it such as LWJGL OpenCL, Javassist, various storage formats for sending across the Internet, an "acyclicFlow" optimization for a binary forest of (double,double)->double ops such as useful for making live music, etc. Code must obey the Op.nondet limiting of compute resources by an incomplete (worked in earlier versions but needs complete rebuild) "spend" and "wallet" ops (which work with $(cost) or $() means $(1)) which are only for compute resources on local computer and are not a cryptocurrency and vary the cost by which optimizations exist at the time and computer (TODO I will prototype those soon). Anything which is 100% compatible per bit and makes it faster, without adding alot of complexity, will be accepted into the code. Creating new java functions just cuz they're convenient will have to remain in your own branch and those who choose to fork it since even if it works with the "ocfnplug" way of calling java functions by reflection, is something that should eventually be derived from the universal lambda and not use Op.nondet, but I'm including some ocfnplug funcs anyways cuz I want to get enough features in the system that I can use the system itself to write the code to do those things with the universal lambda function only. As of now, progress is nearly deadlocked by the assembly-like small set of features available and the need to use only those to derive more features and later either manually or sometimes automatically generate Compiled.java instances and fn.setCompiled(Compiled) to add a new part of the JIT compiler to optimize those so the code is self-aware to see the form derived by universal lambda but actually computes it by more optimized code, unless you turn each individual Compiled instance off in which case it instantly uses the previous Compiled as they are linkedlists of Compiled, and every object has a Compiled, the first of them being those from Boot.java which define the 16 opcodes and the behaviors of the leaf. Mostly, dont break compatibility with the plan that everything will be derived from the universal lambda function and your code will be accepted. I am in violation of this policy but am working on it. Make it better toward that goal instead of expanding horizontally which makes it worse.



=== SOME OF THE OUTPUT FROM TestBasics.java 2020-1-25 ===

fn663: (..(..)(..(..))(.(..)(..)))
fn664: (..(..)(..(..))(.(..)(.(..))))
fn665: (..(..)(..(..))(.(..)(...)))
fn666: (..(..)(..(..))(.(..)(..(..))))
fn667: (..(..)(..(..))(....))
fn668: (..(..)(..(..))(...(..)))
fn669: (..(..)(..(..))(...(.(..))))
fn670: (..(..)(..(..))(...(...)))
fn671: (..(..)(..(..))(...(..(..))))
fn672: (..(..)(..(..))(..(..).))
fn673: (..(..)(..(..))(..(..)(..)))
fn674: (..(..)(..(..))(..(..)(.(..))))
fn675: (..(..)(..(..))(..(..)(...)))
fn676: (..(..)(..(..))(..(..)(..(..))))
Occamsfuncer booted.
Starting at utcSecondsBaseTen:1.5799747299820173E9
cbtFuncBody of l=0 r=1
OPTIMIZED=false
Starting testInfiniteLoopEndsCuzRunsOutOfGas
cbtFuncBody of l=1 r=1
cbtFuncBody of l=<unary1> r=<unary1>
cbtFuncBody of l=<unary2> r=<unary2>
cbtFuncBody of l=<unary3> r=<unary3>
cbtFuncBody of l=<unary4> r=<unary4>
cbtFuncBody of l=<unary5> r=<unary5>
cbtFuncBody of l=(01) r=<unary1>
cbtFuncBody of l=0 r=0
cbtFuncBody of l=(01) r=(00)
cbtFuncBody of l=(01<unary1>) r=(01(00))
cbtFuncBody of l=1 r=0
cbtFuncBody of l=(01) r=<mayBeStr:>
cbtFuncBody of l=(01) r=(01)
cbtFuncBody of l=(01<mayBeStr:>) r=(01(01))
cbtFuncBody of l=(01<unary1>(01(00))) r=(01<mayBeStr:>(01(01)))
cbtFuncBody of l=<mayBeStr:> r=(00)
cbtFuncBody of l=(01<unary1>) r=<mayBeStr:>
cbtFuncBody of l=(01<unary1><mayBeStr:>) r=(01<unary1>(01(00)))
cbtFuncBody of l=(01<unary1>(01(00))(01<mayBeStr:>(01(01)))) r=(01<unary1><mayBeStr:>(01<unary1>(01(00))))
cbtFuncBody of l=(00) r=<mayBeStr:>
cbtFuncBody of l=(00<mayBeStr:>) r=<unary2>
cbtFuncBody of l=(00) r=(00)
cbtFuncBody of l=(01<unary1>) r=(00(00))
cbtFuncBody of l=(00<mayBeStr:><unary2>) r=(01<unary1>(00(00)))
cbtFuncBody of l=<unary1> r=(00)
cbtFuncBody of l=(01<mayBeStr:>) r=(<unary1>(00))
cbtFuncBody of l=(00) r=(01)
cbtFuncBody of l=(01<mayBeStr:>) r=(00(01))
cbtFuncBody of l=(01<mayBeStr:>(<unary1>(00))) r=(01<mayBeStr:>(00(01)))
cbtFuncBody of l=(00<mayBeStr:><unary2>(01<unary1>(00(00)))) r=(01<mayBeStr:>(<unary1>(00))(01<mayBeStr:>(00(01))))
cbtFuncBody of l=(01<unary1>(01(00))(01<mayBeStr:>(01(01)))(01<unary1><mayBeStr:>(01<unary1>(01(00))))) r=(00<mayBeStr:><unary2>(01<unary1>(00(00)))(01<mayBeStr:>(<unary1>(00))(01<mayBeStr:>(00(01)))))
cbtFuncBody of l=<mayBeStr:> r=(01)
cbtFuncBody of l=(01<mayBeStr:>) r=(<mayBeStr:>(01))
cbtFuncBody of l=<unary1> r=<mayBeStr:>
cbtFuncBody of l=(01<mayBeStr:>) r=(<unary1><mayBeStr:>)

...

bootOpChildIndexAtHeight2 of (.(..)) is 0
bootOpChildIndexAtHeight2 of (.(..)) is 0
bootOpChildIndexAtHeight3 of (.(..)(.(..))) is 0
bootOpChildIndexAtHeight2 of (.(..)) is 0
bootOpChildIndexAtHeight2 of (.(..)) is 0
bootOpChildIndexAtHeight3 of (.(..)(.(..))) is 0
bootOpIndexAtHeight4 of <mayBeStr:> is 0
equals={{(C<unary5>),T,<str:c2>},(S(S(S(T{{(C<unary6>),T,<str:c3>},(S(S(S(S(T2)(P<unary5>))(P<unary6>))(P<unary4>))(T.)),<str:ifElse>})(S(T_)(P<unary4>)))({{(C<unary6>),T,<str:c3>},(S(P<unary4>)(P<unary5>)),<str:lazig>}(S(T_)(P<unary5>))))({{(C<unary6>),T,<str:c3>},(S(P<unary4>)(P<unary5>)),<str:lazig>}(S(S(S(T{{(C<unary6>),T,<str:c3>},(S(S(S(S(T2)(P<unary5>))(P<unary6>))(P<unary4>))(T.)),<str:ifElse>})(S(T_)(P<unary5>)))(T(TF)))({{(C<unary6>),T,<str:c3>},(S(P<unary4>)(P<unary5>)),<str:lazig>}(S(S(S(T{{(C<unary6>),T,<str:c3>},(S(S(T{{(C<unary5>),T,<str:c2>},(S(S(P<unary4>)(P<unary5>))(TF)),<str:and>})(S(S(T{{(C<unary5>),T,<str:c2>},(S(S(P<unary4>)(P<unary5>))(TF)),<str:and>})(P<unary4>))(P<unary5>)))(P<unary6>)),<str:and3>})(S(SU(S(TL)(P<unary4>)))(S(TL)(P<unary5>))))(S(SU(S(TR)(P<unary4>)))(S(TR)(P<unary5>))))(S(SU(S(Tm)(P<unary4>)))(S(Tm)(P<unary5>)))))))),<str:equals>}
equalsLeaf=({{(C<unary5>),T,<str:c2>},(S(S(S(T{{(C<unary6>),T,<str:c3>},(S(S(S(S(T2)(P<unary5>))(P<unary6>))(P<unary4>))(T.)),<str:ifElse>})(S(T_)(P<unary4>)))({{(C<unary6>),T,<str:c3>},(S(P<unary4>)(P<unary5>)),<str:lazig>}(S(T_)(P<unary5>))))({{(C<unary6>),T,<str:c3>},(S(P<unary4>)(P<unary5>)),<str:lazig>}(S(S(S(T{{(C<unary6>),T,<str:c3>},(S(S(S(S(T2)(P<unary5>))(P<unary6>))(P<unary4>))(T.)),<str:ifElse>})(S(T_)(P<unary5>)))(T(TF)))({{(C<unary6>),T,<str:c3>},(S(P<unary4>)(P<unary5>)),<str:lazig>}(S(S(S(T{{(C<unary6>),T,<str:c3>},(S(S(T{{(C<unary5>),T,<str:c2>},(S(S(P<unary4>)(P<unary5>))(TF)),<str:and>})(S(S(T{{(C<unary5>),T,<str:c2>},(S(S(P<unary4>)(P<unary5>))(TF)),<str:and>})(P<unary4>))(P<unary5>)))(P<unary6>)),<str:and3>})(S(SU(S(TL)(P<unary4>)))(S(TL)(P<unary5>))))(S(SU(S(TR)(P<unary4>)))(S(TR)(P<unary5>))))(S(SU(S(Tm)(P<unary4>)))(S(Tm)(P<unary5>)))))))),<str:equals>}.)
testEqq pass: equals_leaf_leaf
testEqq pass: equals_leafLeaf_leafLeaf
testEqq pass: equals_leafLeaf_copyOfLeafLeaf
testEqq pass: equals_leaf_leafLeaf
testEqq pass: equalsA
testEqq pass: equalsB
testEqq pass: equalsC
testEqq pass: equalsD
test pass: somethingLambdaFuncsCantDoCuzItWouldInfiniteLoop
test pass: equals(equals,equals)==T
Starting testIota
iota = {(2S),T,<str:iota>}
testEqq pass: (iota iota getp) cuz iota iota is an identityFunc
testEqq pass: get T from iota
testEqq pass: get S from iota
Tests pass: testIota
Starting testTrinaryForest
testEqq pass: comment.f(leaf)
testEqq pass: comment.f(leaf.f(leaf))
testEqq pass: comment.f(COMMENT.f(leaf.f(leaf)).f(cbt1))
testEqq pass: comment.f(COMMENT.f(getp.f(curry)).f(cbt1))
testEqq pass: L.f(COMMENT.f(getp.f(curry)).f(cbt1))
testEqq pass: R.f(COMMENT.f(getp.f(curry)).f(cbt1))
Starting testConsCarCdr
testEqq pass: testConsCarCdr_1
testEqq pass: testConsCarCdr_2
testEqq pass: testConsCarCdr_3
testEqq pass: testConsCarCdr_4
testEqq pass: isNil_nil
testEqq pass: isNil_leaf
testEqq pass: isNil_[list_getp_recur_L]
Starting testOcfnplugDoubleMathRaw_stuffThatWillBeReplacedByUserLevelCodeLater
testEqq pass: raw3 as long bits of double
testEqq pass: raw3 as double is 3
testEqq pass: dMulRaw 2 3
testEqq pass: dMulRaw 2.34 3.45
testEqq pass: dAddRaw 2 3
testEqq pass: dAddRaw 2.34 3.45
The loop of tests to do before optimizing and again after optimizing, all passed.
The next tests never passed as of 2020-1-20 so ending early.


